/* automatically generated by rust-bindgen 0.58.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum boolean_t {
    B_FALSE = 0,
    B_TRUE = 1,
}
pub type uchar_t = ::std::os::raw::c_uchar;
pub type uint_t = ::std::os::raw::c_uint;
pub type hrtime_t = ::std::os::raw::c_longlong;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum data_type_t {
    DATA_TYPE_DONTCARE = -1,
    DATA_TYPE_UNKNOWN = 0,
    DATA_TYPE_BOOLEAN = 1,
    DATA_TYPE_BYTE = 2,
    DATA_TYPE_INT16 = 3,
    DATA_TYPE_UINT16 = 4,
    DATA_TYPE_INT32 = 5,
    DATA_TYPE_UINT32 = 6,
    DATA_TYPE_INT64 = 7,
    DATA_TYPE_UINT64 = 8,
    DATA_TYPE_STRING = 9,
    DATA_TYPE_BYTE_ARRAY = 10,
    DATA_TYPE_INT16_ARRAY = 11,
    DATA_TYPE_UINT16_ARRAY = 12,
    DATA_TYPE_INT32_ARRAY = 13,
    DATA_TYPE_UINT32_ARRAY = 14,
    DATA_TYPE_INT64_ARRAY = 15,
    DATA_TYPE_UINT64_ARRAY = 16,
    DATA_TYPE_STRING_ARRAY = 17,
    DATA_TYPE_HRTIME = 18,
    DATA_TYPE_NVLIST = 19,
    DATA_TYPE_NVLIST_ARRAY = 20,
    DATA_TYPE_BOOLEAN_VALUE = 21,
    DATA_TYPE_INT8 = 22,
    DATA_TYPE_UINT8 = 23,
    DATA_TYPE_BOOLEAN_ARRAY = 24,
    DATA_TYPE_INT8_ARRAY = 25,
    DATA_TYPE_UINT8_ARRAY = 26,
    DATA_TYPE_DOUBLE = 27,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvpair {
    pub nvp_size: i32,
    pub nvp_name_sz: i16,
    pub nvp_reserve: i16,
    pub nvp_value_elem: i32,
    pub nvp_type: data_type_t,
}
#[test]
fn bindgen_test_layout_nvpair() {
    assert_eq!(
        ::std::mem::size_of::<nvpair>(),
        16usize,
        concat!("Size of: ", stringify!(nvpair))
    );
    assert_eq!(
        ::std::mem::align_of::<nvpair>(),
        4usize,
        concat!("Alignment of ", stringify!(nvpair))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvpair>())).nvp_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvpair),
            "::",
            stringify!(nvp_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvpair>())).nvp_name_sz as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvpair),
            "::",
            stringify!(nvp_name_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvpair>())).nvp_reserve as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nvpair),
            "::",
            stringify!(nvp_reserve)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvpair>())).nvp_value_elem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvpair),
            "::",
            stringify!(nvp_value_elem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvpair>())).nvp_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvpair),
            "::",
            stringify!(nvp_type)
        )
    );
}
pub type nvpair_t = nvpair;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvlist {
    pub nvl_version: i32,
    pub nvl_nvflag: u32,
    pub nvl_priv: u64,
    pub nvl_flag: u32,
    pub nvl_pad: i32,
}
#[test]
fn bindgen_test_layout_nvlist() {
    assert_eq!(
        ::std::mem::size_of::<nvlist>(),
        24usize,
        concat!("Size of: ", stringify!(nvlist))
    );
    assert_eq!(
        ::std::mem::align_of::<nvlist>(),
        8usize,
        concat!("Alignment of ", stringify!(nvlist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvlist>())).nvl_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvlist),
            "::",
            stringify!(nvl_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvlist>())).nvl_nvflag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvlist),
            "::",
            stringify!(nvl_nvflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvlist>())).nvl_priv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvlist),
            "::",
            stringify!(nvl_priv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvlist>())).nvl_flag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvlist),
            "::",
            stringify!(nvl_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvlist>())).nvl_pad as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvlist),
            "::",
            stringify!(nvl_pad)
        )
    );
}
pub type nvlist_t = nvlist;
extern "C" {
    pub fn nvlist_add_nvpair(arg1: *mut nvlist_t, arg2: *mut nvpair_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvlist_remove_nvpair(arg1: *mut nvlist_t, arg2: *mut nvpair_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvlist_lookup_nvpair(
        arg1: *mut nvlist_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut nvpair_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvlist_lookup_nvpair_embedded_index(
        arg1: *mut nvlist_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut nvpair_t,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvlist_next_nvpair(arg1: *mut nvlist_t, arg2: *mut nvpair_t) -> *mut nvpair_t;
}
extern "C" {
    pub fn nvlist_prev_nvpair(arg1: *mut nvlist_t, arg2: *mut nvpair_t) -> *mut nvpair_t;
}
extern "C" {
    pub fn nvpair_name(arg1: *mut nvpair_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nvpair_type(arg1: *mut nvpair_t) -> data_type_t;
}
extern "C" {
    pub fn nvpair_type_is_array(arg1: *mut nvpair_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_boolean_value(
        arg1: *mut nvpair_t,
        arg2: *mut boolean_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_byte(arg1: *mut nvpair_t, arg2: *mut uchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_int8(arg1: *mut nvpair_t, arg2: *mut i8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_uint8(arg1: *mut nvpair_t, arg2: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_int16(arg1: *mut nvpair_t, arg2: *mut i16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_uint16(arg1: *mut nvpair_t, arg2: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_int32(arg1: *mut nvpair_t, arg2: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_uint32(arg1: *mut nvpair_t, arg2: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_int64(arg1: *mut nvpair_t, arg2: *mut i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_uint64(arg1: *mut nvpair_t, arg2: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_string(
        arg1: *mut nvpair_t,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_nvlist(
        arg1: *mut nvpair_t,
        arg2: *mut *mut nvlist_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_boolean_array(
        arg1: *mut nvpair_t,
        arg2: *mut *mut boolean_t,
        arg3: *mut uint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_byte_array(
        arg1: *mut nvpair_t,
        arg2: *mut *mut uchar_t,
        arg3: *mut uint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_int8_array(
        arg1: *mut nvpair_t,
        arg2: *mut *mut i8,
        arg3: *mut uint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_uint8_array(
        arg1: *mut nvpair_t,
        arg2: *mut *mut u8,
        arg3: *mut uint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_int16_array(
        arg1: *mut nvpair_t,
        arg2: *mut *mut i16,
        arg3: *mut uint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_uint16_array(
        arg1: *mut nvpair_t,
        arg2: *mut *mut u16,
        arg3: *mut uint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_int32_array(
        arg1: *mut nvpair_t,
        arg2: *mut *mut i32,
        arg3: *mut uint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_uint32_array(
        arg1: *mut nvpair_t,
        arg2: *mut *mut u32,
        arg3: *mut uint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_int64_array(
        arg1: *mut nvpair_t,
        arg2: *mut *mut i64,
        arg3: *mut uint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_uint64_array(
        arg1: *mut nvpair_t,
        arg2: *mut *mut u64,
        arg3: *mut uint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_string_array(
        arg1: *mut nvpair_t,
        arg2: *mut *mut *mut ::std::os::raw::c_char,
        arg3: *mut uint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_nvlist_array(
        arg1: *mut nvpair_t,
        arg2: *mut *mut *mut nvlist_t,
        arg3: *mut uint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_hrtime(arg1: *mut nvpair_t, arg2: *mut hrtime_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_double(arg1: *mut nvpair_t, arg2: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fnvlist_add_nvpair(arg1: *mut nvlist_t, arg2: *mut nvpair_t);
}
extern "C" {
    pub fn fnvlist_remove_nvpair(arg1: *mut nvlist_t, arg2: *mut nvpair_t);
}
extern "C" {
    pub fn fnvlist_lookup_nvpair(
        arg1: *mut nvlist_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut nvpair_t;
}
extern "C" {
    pub fn fnvpair_value_boolean_value(nvp: *mut nvpair_t) -> boolean_t;
}
extern "C" {
    pub fn fnvpair_value_byte(nvp: *mut nvpair_t) -> uchar_t;
}
extern "C" {
    pub fn fnvpair_value_int8(nvp: *mut nvpair_t) -> i8;
}
extern "C" {
    pub fn fnvpair_value_int16(nvp: *mut nvpair_t) -> i16;
}
extern "C" {
    pub fn fnvpair_value_int32(nvp: *mut nvpair_t) -> i32;
}
extern "C" {
    pub fn fnvpair_value_int64(nvp: *mut nvpair_t) -> i64;
}
extern "C" {
    pub fn fnvpair_value_uint8(nvp: *mut nvpair_t) -> u8;
}
extern "C" {
    pub fn fnvpair_value_uint16(nvp: *mut nvpair_t) -> u16;
}
extern "C" {
    pub fn fnvpair_value_uint32(nvp: *mut nvpair_t) -> u32;
}
extern "C" {
    pub fn fnvpair_value_uint64(nvp: *mut nvpair_t) -> u64;
}
extern "C" {
    pub fn fnvpair_value_string(nvp: *mut nvpair_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fnvpair_value_nvlist(nvp: *mut nvpair_t) -> *mut nvlist_t;
}
pub type __re_long_size_t = ::std::os::raw::c_ulong;
pub type reg_syntax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_pattern_buffer {
    pub __buffer: *mut re_dfa_t,
    pub __allocated: __re_long_size_t,
    pub __used: __re_long_size_t,
    pub __syntax: reg_syntax_t,
    pub __fastmap: *mut ::std::os::raw::c_char,
    pub __translate: *mut ::std::os::raw::c_uchar,
    pub re_nsub: size_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_re_pattern_buffer() {
    assert_eq!(
        ::std::mem::size_of::<re_pattern_buffer>(),
        64usize,
        concat!("Size of: ", stringify!(re_pattern_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<re_pattern_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(re_pattern_buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).__buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(__buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).__allocated as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(__allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).__used as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(__used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).__syntax as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(__syntax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).__fastmap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(__fastmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).__translate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(__translate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).re_nsub as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(re_nsub)
        )
    );
}
impl re_pattern_buffer {
    #[inline]
    pub fn __can_be_null(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___can_be_null(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __regs_allocated(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set___regs_allocated(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __fastmap_accurate(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___fastmap_accurate(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __no_sub(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___no_sub(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __not_bol(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___not_bol(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __not_eol(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___not_eol(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __newline_anchor(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___newline_anchor(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __can_be_null: ::std::os::raw::c_uint,
        __regs_allocated: ::std::os::raw::c_uint,
        __fastmap_accurate: ::std::os::raw::c_uint,
        __no_sub: ::std::os::raw::c_uint,
        __not_bol: ::std::os::raw::c_uint,
        __not_eol: ::std::os::raw::c_uint,
        __newline_anchor: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __can_be_null: u32 = unsafe { ::std::mem::transmute(__can_be_null) };
            __can_be_null as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let __regs_allocated: u32 = unsafe { ::std::mem::transmute(__regs_allocated) };
            __regs_allocated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __fastmap_accurate: u32 = unsafe { ::std::mem::transmute(__fastmap_accurate) };
            __fastmap_accurate as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __no_sub: u32 = unsafe { ::std::mem::transmute(__no_sub) };
            __no_sub as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __not_bol: u32 = unsafe { ::std::mem::transmute(__not_bol) };
            __not_bol as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let __not_eol: u32 = unsafe { ::std::mem::transmute(__not_eol) };
            __not_eol as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __newline_anchor: u32 = unsafe { ::std::mem::transmute(__newline_anchor) };
            __newline_anchor as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type regex_t = re_pattern_buffer;
extern "C" {
    pub fn nvpair_value_match(
        arg1: *mut nvpair_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvpair_value_match_regex(
        arg1: *mut nvpair_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut regex_t,
        arg5: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_dfa_t {
    pub _address: u8,
}
